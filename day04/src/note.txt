回顾:
  数组: 3种初始化方式
       长度length, 长度不可变
       引用类型 -> 堆
       访问, index: 0~length-1
       内存图: 非常重要
  方法:
    修饰词  返回值类型  名字(参数列表) {方法体}
    方法签名: 方法名+参数列表
    返回值: return
    调用: 执行方法体
  JVM:
    方法区: 类加载后的信息
    栈: 临时变量\局部变量
    堆: 引用的数据

  方法参数: 基本数据类型, 就是传递的是值
           引用类型, 传递的是引用-地址

数组排序: 升序
  1.选择排序: 每一轮都选择一个最大的, 放在最后面
  2.冒泡排序: 每一轮比较相邻两个元素, 小的放前面, 大的放后面
  3.插入排序: 将数组分成两部分, 一部分是已经排好的, 另一部分挨个访问, 插入到前一部分合适的地方

  冒泡排序分析: arr: 8 , 2 , 3 , 7 , 1: length=5
    第一轮: i=0
       2, 8, 3, 7, 1  j=0   arr[j] > arr[j+1]->交换
       2, 3, 8, 7, 1  j=1
       2, 3, 7, 8, 1  j=2
       2, 3, 7, 1, 8  j=3
    第二轮: i=1
       2, 3, 7, 1, 8  j=0
       2, 3, 7, 1, 8  j=1
       2, 3, 1, 7, 8  j=2
    第三轮: i=2
       2, 3, 1, 7, 8  j=0
       2, 1, 3, 7, 8  j=1
    第四轮: i=3
       1, 2, 3, 7, 8  j=0
    i: i=0; i < length-1;i++
    j: j=0; j < length-1-i;j++

  选择: arr: 8 , 2 , 3 , 7 , 1
    第一轮:
        默认index=0
       1: 如果 arr[1] > arr[index], index就替换掉, index=0
       2: 如果 arr[2] > arr[index], index就替换掉, index=0
       3: 如果 arr[3] > arr[index], index就替换掉, index=0
       4: 如果 arr[4] > arr[index], index就替换掉, index=0
       交换 index位置 和 当前最后一个位置 length-1
       1 , 2 , 3 , 7 , 8
       i:0
       j:1~5
    第二轮:
       1: arr[0] 比较 arr[1], 记录index=0
       2: 如果 arr[2] > arr[index], index就替换掉, index=2
       3: 如果 arr[3] > arr[index], index就替换掉, index=3
       交换 index位置 和 当前最后一个位置 length-1-1
       1 , 2 , 3 , 7 , 8
       i:1
       j:1~4
    第三轮:
       1: arr[0] 比较 arr[1], 记录index=0
       2: 如果 arr[2] > arr[index], index就替换掉, index=2
       交换 index位置 和 当前最后一个位置 length-1-2
       1 , 2 , 3 , 7 , 8
       i:2
       j:1~3
    第四轮:
       1: arr[0] 比较 arr[1], 记录index=0
       交换 index位置 和 当前最后一个位置 length-1-3
       1 , 2 , 3 , 7 , 8
       i:3
       j:2
    i: i=0; i < length-1;i++
    j: j=1; j < length-i;j++

面向对象: OOP   Object Oriented Programming
    一切皆对象, Java操作的基本单位就是对象
    类/类型: 所有同种对象共同的特征和行为, 抽象出来成为类
    对象: 符合类的实例化个体

学生特征: - 属性/成员变量
  姓名  性别  年龄  课程方向  学号....
学生行为: - 成员方法
  吃饭  学习  说话  睡觉
以上抽象出一个概念: 类 - 学生, 实体类
对象: 符合类的特征的独立个体
类和对象的关系: 先定义/声明 类, 然后再创建对象

class: 类 类型 和int功能一样
使用对象的步骤:
    1.必须先有类
    class Student {
        成员变量 name age
        成员方法
    }
    2.才能创建对象 - main - 方法 - 存在于类中
        Student s = new Student();
    3.有了对象, 对象包含了成员变量(name和age)和成员方法
        使用, 用 . 来调用的

局部变量和成员变量的区别
    1.声明位置
        局部变量: 方法中
        成员变量: 类中
    2.初始化
        局部变量: 使用前必须初始化
        成员变量: 可以初始化, 如果没有初始化, 会有默认初始值
    3.个数
        局部变量: 声明个数
        成员变量: 由对象决定, 有几个对象就有几个成员变量
    4.内存中的位置
        第一次使用类[创建类的对象]之前, 会先将类进行加载
        局部变量: 方法栈中, 方法结束, 局部变量消失
        成员变量: 跟对象一起, 在堆中

方法重载:
    方法名一样, 参数列表不一样的几个方法
    跟返回值类型无关
    举例: println print
    参数列表不一样的情况: 个数不同\类型不同\顺序不同
        (int a)
        (double d)
        (int a, int b)
        (int b, int a) ×
        (int a, float b)
        (float b, int a)

构造方法/构造器:
   目的: 为了给成员变量初始化
   特点: 方法名要和类名一致
        没有返回值类型
   构造方法可以重载
   当类中没有定义构造方法时, 编译器会默认添加无参构造方法

this:
   表示当前对象 - 这个对象
   哪个对象调用方法, 就表示哪个对象
   this可以调用自己的成员变量, 当成员变量和临时变量重名时, this不能省
   this也可以调用自己的成员方法, this可以省略
   this也可以调用自己的构造方法, this(参数), this不能省
       只能放在构造方法的第一行

NullPointerException: 空指针异常
    产生原因: 调用了null空值得 成员变量 或者 方法

引用类型的数组
    使用步骤:
     1.给数组初始化
        Student[] ss = new Student[5]; // 默认值都是null
     2.给数组元素初始化
        ss[0] = new Student();
        ss[1] = new Student();
        ...

命名规则：
	1.只能出现：英文 + 数字 + _ + $
	2.不能以数字开头
	3.变量名：可读性好、首字母小写、第二个单词开始首字母大写
	4.包名：全部小写，域名倒写
		www.baidu.com
		com.baidu.zhidao.xx.xx
		com.baidu.baike.xx.xx
    5.方法名: 首字母小写、第二个单词开始首字母大写 - 驼峰命名法
             长度不限, 但是一定要可读性好
    6.类名: 驼峰命名法, 首字母大写
           System Scanner Math Arrays


